"""
Text Optimizer Backend — Single-file FastAPI app
- Features:
  - Accept raw text or a URL to fetch and summarize/optimize.
  - Uses OpenAI (Chat) API to: optimize text (clarify, shorten, preserve meaning), extract key points, list main concepts, and give a concise conclusion + action items.
  - Returns structured JSON with fields: optimized_text, key_points, concepts, conclusion, suggestions, raw_model_response.

Usage:
1) Install dependencies:
   pip install fastapi uvicorn openai requests beautifulsoup4 python-multipart

2) Set environment variable:
   export OPENAI_API_KEY="sk-..."   (Windows: setx OPENAI_API_KEY "sk-...")

3) Run:
   uvicorn fastapi_text_optimizer:app --reload --host 0.0.0.0 --port 8000

Endpoints:
- POST /api/optimize
  Body (json): { "text": "...", "url": "...", "model": "gpt-4o-mini" }
  Either `text` or `url` must be provided. If both, `text` is used.

- GET / (simple HTML form for manual testing)

Notes & customization points:
- You can change the model param to any model available on your OpenAI account.
- The prompt template is in `build_prompt()` and easy to tune for different flavors of optimization (e.g., academic, marketing, kids-level).

"""

from fastapi import FastAPI, HTTPException, Request, Form
from fastapi.responses import JSONResponse, HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import os
import openai
import requests
from bs4 import BeautifulSoup
import asyncio

# Initialize
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    # We'll not raise at import time to keep the file loadable in environments where key isn't set.
    pass
else:
    openai.api_key = OPENAI_API_KEY

app = FastAPI(title="Text Optimizer Backend")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class OptimizeRequest(BaseModel):
    text: str = None
    url: str = None
    model: str = "gpt-4o-mini"


async def fetch_url_text(url: str, timeout: int = 10) -> str:
    """Fetch a URL and return cleaned visible text."""
    try:
        resp = requests.get(url, timeout=timeout, headers={"User-Agent": "TextOptimizer/1.0"})
        resp.raise_for_status()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Failed to fetch URL: {e}")

    soup = BeautifulSoup(resp.text, "html.parser")

    # Remove scripts/styles
    for s in soup(["script", "style", "noscript"]):
        s.extract()

    # Get text blocks
    texts = [t.get_text(separator=" ", strip=True) for t in soup.find_all(['p', 'li', 'h1', 'h2', 'h3', 'h4'])]
    joined = "\n\n".join([t for t in texts if t])
    # Fallback: full body text if fragments empty
    if not joined:
        joined = soup.get_text(separator=" ", strip=True)
    return joined[:20000]  # limit to first 20k chars to be safe


def build_prompt(source_text: str) -> str:
    """Create the prompt sent to the model. Keep it structured so the model returns JSON-like output."""
    prompt = f"""
You are an expert editor and teacher. A user will provide a piece of text. Your job is to:
1) Produce an *optimized* version: clearer, concise, better flow, preserving original meaning. If the text is long, produce a short & a long optimized version.
2) Extract the top 8 *key points* (short bullets) that the text makes.
3) List the main *concepts/terms* mentioned (as short phrases).
4) Provide a one-paragraph *conclusion* summarizing the overall message.
5) Provide 3 practical *suggestions* or action items the reader can do next.

Respond in JSON with fields exactly named: optimized_text, optimized_text_short, key_points, concepts, conclusion, suggestions, notes.
- optimized_text: the edited full text.
- optimized_text_short: 1-3 sentence concise version.
- key_points: array of up to 8 short strings.
- concepts: array of named concepts (3-12 items).
- conclusion: string (one paragraph).
- suggestions: array of 2-5 actionable items.
- notes: any caveats, assumptions, or important context about the optimization.

Here is the text to analyze:
---
{source_text}
---

Do not include any commentary outside the JSON. If you cannot fill a field, use null. Keep the JSON parseable.
""".strip()
    return prompt


@app.post("/api/optimize")
async def optimize(req: OptimizeRequest):
    # Validate input
    if not req.text and not req.url:
        raise HTTPException(status_code=400, detail="Either 'text' or 'url' must be provided.")

    # Fetch url if needed
    source = req.text
    if not source and req.url:
        source = await asyncio.to_thread(fetch_url_text, req.url)

    if not source or source.strip() == "":
        raise HTTPException(status_code=400, detail="Source text is empty after fetching/parsing.")

    # Ensure API key
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise HTTPException(status_code=500, detail="Server-side: OPENAI_API_KEY not set.")

    openai.api_key = api_key

    prompt = build_prompt(source)

    try:
        # Use chat completion
        response = openai.ChatCompletion.create(
            model=req.model,
            messages=[
                {"role": "system", "content": "You are a helpful assistant that outputs strict JSON as requested."},
                {"role": "user", "content": prompt},
            ],
            temperature=0.0,
            max_tokens=1500,
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"OpenAI API error: {e}")

    raw = response.choices[0].message['content']

    # Try to parse JSON out of the model output safely.
    import json, re

    # Extract the first JSON object in the output
    m = re.search(r"\{(?:.|\n)*\}", raw)
    parsed = None
    if m:
        json_text = m.group(0)
        try:
            parsed = json.loads(json_text)
        except Exception:
            # best-effort: try to fix common single quotes or trailing commas
            fixed = json_text.replace("\'", '"')
            fixed = re.sub(r",\s*\}", "}", fixed)
            try:
                parsed = json.loads(fixed)
            except Exception:
                parsed = None

    # Build response
    result = {
        "ok": True,
        "model": req.model,
        "raw_model_response": raw,
        "parsed": parsed,
    }

    return JSONResponse(result)


@app.get("/", response_class=HTMLResponse)
async def homepage():
    html = """
<!doctype html>
<html>
  <head><meta charset="utf-8"><title>Text Optimizer (Demo)</title></head>
  <body>
    <h2>Text Optimizer — Demo form</h2>
    <form method="post" action="/demo_optimize">
      <label>Paste text (preferred):</label><br>
      <textarea name="text" rows="12" cols="80"></textarea><br>
      <label>Or URL to fetch:</label><br>
      <input name="url" size="80"/><br><br>
      <button type="submit">Optimize</button>
    </form>
  </body>
</html>
"""
    return HTMLResponse(content=html)


@app.post('/demo_optimize', response_class=HTMLResponse)
async def demo_optimize(text: str = Form(None), url: str = Form(None)):
    # Simple web form handler that calls /api/optimize
    payload = {"text": text, "url": url}
    # Call internal function to reuse logic
    req = OptimizeRequest(**payload)
    resp = await optimize(req)
    return resp


if __name__ == '__main__':
    import uvicorn
    uvicorn.run('fastapi_text_optimizer:app', host='0.0.0.0', port=8000, reload=True)
